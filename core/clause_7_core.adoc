== Requriements Class "Core"

[[core-overview]]
=== Overview

include::requirements/requirements_class_core.adoc[]

An API that implements this conformance class provides access to the coverages in a link:https://www.w3.org/TR/vocab-dcat/#class-dataset[dataset]. In other words, the API is a link:https://www.w3.org/TR/vocab-dcat/#class-distribution[distribution] of that dataset. A file download, for example, would be another distribution.

NOTE: Other parts of this standard may define API extensions that support multiple datasets. The statement that the features are from "a dataset" is not meant to preclude such extensions. It just reflects that this document does not specify how the API publishes coverages or other spatial data from multiple datasets.

The entry point is a `Landing page` (path `/`).

NOTE: All paths (e.g., `/`) are relative to the base URL of the distribution of the dataset. If the API covers other resources beyond those specified in this document, the landing page may also be, for example, a sub-resource of the base URL of the API.

The `Landing page` provides links to

* the `API definition` (path `/api`, link relation `service`),
* the `Conformance declaration` (path `/conformance`, link relation `conformance`), and
* the `Collections` (path `/collections`, link relation `data`).

The `API definition` describes the capabilities of the server that can be used by clients to connect to the server or by development tools to support the implementation of servers and clients. Accessing the `API definition` using HTTP GET returns a description of the API.

The `Conformance declaration` states the requirements classes from standards or community specifications, identified by a URI, that the API conforms to. Clients can but are not required to use this information. Accessing the `Conformance declaration` using HTTP GET returns the list of URIs of requirements classes implemented by the server.

The data is organized into one or more collections. `Collections` provides information about and access to the collections.

This document specifies requirements only for collections consisting of coverages. That is, each
collection considered by this document is a collection of coverages.

This standard does not include any requirements about how the coverages in the dataset have to be aggregated into collections. A typical approach is to aggregate by collection type but any other approach that fits the dataset or the applications using this distribution may also be used.

Accessing `Collections` using HTTP GET returns a response that contains at least the list of collections. For each `Collection`, a link to the items in the collection (`Coverages`, path `/collections/{collectionId}/items`, link relation `items`) as well as key information about the collection. This information includes:

* A local identifier for the collection that is unique for the dataset;
* A list of coordinate reference systems (CRS) in which geometries may be returned by the server. The first CRS is the default coordinate reference system (in the _Core_, the default is always WGS 84 with axis order longitude/latitude);
* An optional title and description for the collection;
* An optional extent that can be used to provide an indication of the spatial and temporal extent of the collection - typically derived from the data;
* An optional indicator about the type of the items in the collection (the default value, if the indicator is not provided, is 'coverage').

The `Collection` resource is available at path `/collections/{collectionId}`, too, often with more details than included in the `Collections` response.

Each `Collection` that is a collection of coverages consists of coverages. This document only discusses the behavior of coverage collections.

Each coverage in a dataset is part of exactly one collection.

Accessing the `Coverages` using HTTP GET returns a document consisting of coverages in the collection. The coverages included in the response are determined by the server based on the query parameters of the request. To support access to larger collections without overloading the client, the API supports paged access with links to the next page, if more features are selected that the page size.

A `bbox` or `datetime` parameter may be used to select only a subset of the coverages in the collection (the coverages that are in the bounding box or time interval). The `bbox` parameter matches all covearges in the collection that are not associated with a location, too. The `datetime` parameter matches all coverages in the collection that are not associated with a time stamp or interval, too.

The `limit` parameter may be used to control the subset of the selected coverages that should be returned in the response, the page size.

Each page may include information about the number of selected and returned coverages (`numberMatched` and `numberReturned`) as well as links to support paging (link relation `next`).

Each `Coverage` (path `/collections/{collectionId}/items/{coverageId}`) is also a separate resource and may be requested individually using HTTP GET.

In addition to the simple path structures described above, where all coverages are organized in a one-level collection hierarchy, additional parts of the OGC API Coverage series are expected to provide alternate access to the coverages served by the API via additional, deeper collection hierarchies.

=== API landing page

The OGC strives to maintain a consistent look and feel across all of its' API standards. To that end, features which are common across APIs are defined in the OGC API-Common standard. The API-Common requirements applicable to the API Landing Page are as follows: 

include::requirements/core/REQ_root-common.adoc[]

.link:https://raw.githubusercontent.com/opengeospatial/ogc_api_common/master/core/openapi/schemas/landingPage.yaml[Schema for the landing page]
[source,YAML]
----
type: object
required:
  - links
properties:
  title:
    type: string
  description:
    type: string
specification.
  links:
    type: array
    items:
      $ref: link.yaml
----

.Landing page response document
=================
[source,JSON]
----
{
  "title": "Coverages over Bonn",
  "description": "Access to coverages which include the city of Bonn via a Web API that conforms to the OGC API Coverages specification.",
  "links": [
    { "href": "http://data.example.org/",
      "rel": "self", "type": "application/json", "title": "this document" },
    { "href": "http://data.example.org/api",
      "rel": "service", "type": "application/openapi+json;version=3.0", "title": "the API definition" },
    { "href": "http://data.example.org/conformance",
      "rel": "conformance", "type": "application/json", "title": "OGC API conformance classes implemented by this server" },
    { "href": "http://data.example.org/collections",
      "rel": "data", "type": "application/json", "title": "Metadata about the collections" }
  ]
}
----
=================

=== API definition

Every API is expected to provide a definition that describes the capabilities of the server and which can be used by developers to understand the API, by software clients to connect to the server, or by development tools to support the implementation of servers and clients.

There are no coverage-specific requirements realated to the API definition request or response. API-Common requirements are sufficient to describe this capability for the API-Coverages standard. The API-Common requirements applicable to the API Definition are as follows:

include::requirements/core/REQ_api-common.adoc[]

If multiple API definition formats are supported by a server, use content negotiation to select the desired representation.

The idea is that any OGC API Coverage implementation can be used by developers that are familiar with the API definition language(s) supported by the server. For example, if an OpenAPI definition is used, it should be possible to create a working client using the OpenAPI definition. The developer may need to learn a little bit about geometry data types, etc., but it should not be required to read this standard to access the data via the API.

Two example OpenAPI documents are included in <<oas30_example,Annex B>>. The documents differ in their representation of the coverage collections. The first example uses a path parameter `collectionId` and the API definition only has a single path entry for all coverage collections. The second example explicitly defines each coverage collection in a separate path and without a path parameter - this allows clients to specify filter parameters or explicit coverage types per coverage collection. Both variants are valid.

=== Declaration of conformance classes

To support "generic" clients that want to access multiple OGC API Coverage implementations - and not "just" a specific API / server, the server has to declare the requirements classes it implements and conforms to.

There are no coverage-specific requirements realated to the Requirements Classes. API-Common requirements are sufficient to describe this capability for the API-Coverages standard. The applicable API-Common requirements are as follows:

include::requirements/core/REQ_conformance-common.adoc[]


.link:https://raw.githubusercontent.com/opengeospatial/oapi_common/master/core/openapi/schemas/req-classes.yaml[Schema for the list of requirements classes]
[source,YAML]
----
type: object
required:
  - conformsTo
properties:
  conformsTo:
    type: array
    items:
      type: string
----

.Requirements class response document
=================
This example response in JSON is for a server that supports OpenAPI 3.0 for the API definition and HTML and GeoJSON as encodings for metadata.

[source,JSON]
----
{
  "conformsTo": [
    "http://www.opengis.net/spec/ogc_api-coverages/1.0/req/core",
    "http://www.opengis.net/spec/ogc_api-coverages/1.0/req/oas30",
    "http://www.opengis.net/spec/ogc_api-coverages/1.0/req/html",
    "http://www.opengis.net/spec/ogc_api-coverages/1.0/req/geojson"
  ]
}
----
=================

=== HTTP 1.1

HTTP is the network protocol underlying all Web APIs. 

There are no coverage-specific requirements realated to network protocols. API-Common requirements are sufficient to describe this capability for the API-Coverages standard. The applicable API-Common requirements are as follows:

include::requirements/core/REQ_http-common.adoc[]

[[http_status_codes]]
==== HTTP status codes

This API standard does not impose any restictions on which features of the HTTP and HTTPS protocols may be used. API clients should be prepared to handle any legal HTTP or HTTPS status code. 

The *Status Codes* listed in <<status_codes>> are of particular relevance to implementors of this standard. Status codes 200, 400, and 404 are called out in API requirements. Therefore, support for these status codes is mandatory for all compliant implementations. The remainder of the status codes in <<status_codes>> are not mandatory, but are important for the implementation of a well functioning API. Support for these status codes is strongly encouraged for both client and server implementations.

[#status_codes,reftext='{table-caption} {counter:table-num}']
.Typical HTTP status codes
[cols="15,85",options="header"]
!===
|Status code |Description
|`200` |A successful request.
|`304` |An <<web_caching,entity tag was provided in the request>> and the resource has not been changed since the previous request.
|`400` |The server cannot or will not process the request due to an apparent client error. For example, a query parameter had an incorrect value.
|`401` |The request requires user authentication. The response includes a `WWW-Authenticate` header field containing a challenge applicable to the requested resource.
|`403` |The server understood the request, but is refusing to fulfill it. While status code `401` indicates missing or bad authentication, status code `403` indicates that authentication is not the issue, but the client is not authorised to perform the requested operation on the resource.
|`404` |The requested resource does not exist on the server. For example, a path parameter had an incorrect value.
|`405` |The request method is not supported. For example, a POST request was submitted, but the resource only supports GET requests.
|`406` |The `Accept` header submitted in the request did not support any of the media types supported by the server for the requested resource.
|`500` |An internal error occurred in the server.
!===

More specific guidance is provided for each resource, where applicable.

include::recommendations/core/PER_additional-status-codes.adoc[]

The API Description Document describes the HTTP status codes generated by that API. This should not be an exhaustive list of all possible status codes. It is not reasonable to expect an API designer to control the use of HTTP status codes which are not generated by their software. Therefore, it is recommended that the API Description Document limit itself to describing HTTP status codes relevant to the proper operation of the API application logic. Client implementations should be prepared to receive HTTP status codes in addition to those described in the API Description Document.  

[[query_parameters]]
=== Unknown or invalid query parameters

There are no coverage-specific requirements realated to unknown or invalid query parameters. API-Common requirements are sufficient to describe this capability for the API-Coverages standard. The applicable API-Common requirements are as follows:

include::requirements/core/REQ_query-param-common.adoc[]

==== Unknown query parameters

If an API wants to support vendor specific parameters, these have to be explicitly declared in the API definition.

If OpenAPI is used to represent the API definition, a capability exists to allow additional parameters without explicitly declaring them. That is, parameters that have not been explicitly specified in the API definition for the operation will be ignored.

.OpenAPI schema for additional "free-form" query parameters
[source,YAML]
----
in: query
name: vendorSpecificParameters
schema:
  type: object
  additionalProperties: true
style: form
----

Note that the name of the parameter does not matter as the actual query parameters are the names of the object properties. For example, assume that the value of `vendorSpecificParameters` is this object:

[source,JSON]
----
{
  "my_first_parameter": "some value",
  "my_other_parameter": 42
}
----

In the request URI this would be expressed as `&my_first_parameter=some%20value&my_other_parameter=42`.

==== Invalid query parameters

There is a general rule that applies to all parameters, whether they are specified in this document or in additional parts. A value is invalid if it violates the API definition or any other constraint for that parameter stated in a requirement.

[[encodings]]
=== Encodings

While OGC API Coverages does not specify any mandatory encoding, support for the following encodings is recommended. See <<overview,Clause 6 (Overview)>> for a discussion.

include::recomendations/core/REC_html.adoc[]

include::recomendations/core/REC_geojson.adoc[]

<<_http_1_1,Requirement `/req/core/http`>> implies that the encoding of a server response is determined using content negotiation as specified by the HTTP RFC.

The section <<mediatypes,Media Types>> includes guidance on media types for <<encodings,encodings>> that are specified in this document.

Note that any server that supports multiple encodings will have to support a mechanism to mint encoding-specific URIs for resources in order to express links, for example, to alternate representations of the same resource. This document does not mandate any particular approach how this is supported by the server.

As clients simply need to dereference the URI of the link, the implementation details and the mechanism how the encoding is included in the URI of the link are not important. Developers interested in the approach of a particular implementation, for example, to manipulate ("hack") URIs in the browser address bar, can study the API definition.

[NOTE]
=====================================================================
Two common approaches are:

* an additional path for each encoding of each resource (this can be expressed, for example, using format specific suffixes like ".html");
* an additional query parameter (for example, "accept" or "f") that overrides
the Accept header of the HTTP request.
=====================================================================

[[string_i18n]]
=== String internationalization

If the server supports representing resources in multiple languages, the usual HTTP content negotiation mechanisms apply. The client states its language preferences in the `Accept-Language` header of a request and the server responds with responses that have linguistic text in the language that best matches the requested languages and the capabilities of the server.

include::recomendations/core/REC_string_i18n.adoc[]

For example, if JSON-LD is used as an encoding, the built-in capabilities to link:https://www.w3.org/TR/json-ld/#string-internationalization[annotate a string with its language]
should be used.

The link:https://raw.githubusercontent.com/opengeospatial/oapi_common/master/core/openapi/schemas/link.yaml[link object] based on <<rfc8228,RFC 8288 (Web Linking)>> includes a `hreflang` attribute that can be used to state the language of the referenced resource. This can be used to include links to the same data in, for example, English or French. Just like with <<encodings,multiple encodings>> a server that wants to use language-specific links will have to support a mechanism to mint language-specific URIs for resources in order to express links to, for example, the same resource in another language. Again, this document does not mandate any particular approach how such a capability is supported by the server.

=== Coordinate reference systems

As discussed in Chapter 9 of the <<SDWBP,W3C/OGC Spatial Data on the Web Best Practices document>>, how to express and share the location of a coverage in a consistent way is one of the most fundamental aspects of coverage data and it is important to be clear about the coordinate reference system that coordinates are in.

For the reasons discussed in the Best Practices, OGC API Coverages uses WGS 84 longitude and latitude as the default coordinate reference system.

include::requirements/core/REQ_crs84-common.adoc[]

=== Collections metadata

Path = /collections


include::requirements/core/REQ_cc-md-common.adoc[]

CCCCCCCCCCCCCCCCCCCCCC

.link:https://raw.githubusercontent.com/opengeospatial/OAPI_Common/master/core/openapi/schemas/content.yaml[Schema for the metadata about resource collections]
[source,YAML]
----
type: object
required:
  - links
  - collections
properties:
  links:
    type: array=== Collections metadata

==== Operation

include::requirements/core/REQ_rc-md-op.adoc[]

==== Response

include::requirements/core/REQ_rc-md-success.adoc[]

.link:https://raw.githubusercontent.com/opengeospatial/OAPI_Common/master/core/openapi/schemas/content.yaml[Schema for the metadata about resource collections]
[source,YAML]
----
type: object
required:
  - links
  - collections
properties:
  links:
    type: array
    items:=== Collections metadata

    items:=== Collections metadata

==== Operation

include::requirements/core/REQ_rc-md-op.adoc[]

==== Response

include::requirements/core/REQ_rc-md-success.adoc[]

.link:https://raw.githubusercontent.com/opengeospatial/OAPI_Common/master/core/openapi/schemas/content.yaml[Schema for the metadata about resource collections]
[source,YAML]
----
type: object
required:
  - links
  - collections
properties:
  links:
    type: array
    items:
      $ref: http
      $ref: https://raw.githubusercontent.com/opengeospatial/OAPI_Common/master/core/openapi/schemas/link.yaml
  collections:
    type: array
    items:
      $ref: https://raw.githubusercontent.com/opengeospatial/OAPI_Common/master/core/openapi/schemas/collectionInfo.yaml
----

include::requirements/core/REQ_rc-md-links.adoc[]

include::recommendations/core/REC_rc-md-descriptions.adoc[]

Examples for descriptions are: XML Schema, Schematron, JSON Schema, RDF Schema, OWL, SHACL, a feature catalogue, etc.

include::requirements/core/REQ_rc-md-items.adoc[]

include::recommendations/core/PER_rc-md-items.adoc[]

This document does not specify mechanisms how clients may access all collections from APIs with many collections. Such mechanisms may be specified in additional parts of OGC API Common or in the resource-specific API standards. 

CCCCCCCCCCCCCCCC

=== Collections metadata

Describes the {collectionId} coverage collection

==== Path Template: 

/collections/{collectionId}

==== Path Parameters:

[[collectionId]]
.CollectionID Parameter
=================
[source,JSON]
"collectionId" : {
    "name" : "collectionId",
    "in" : "path",
    "description" : "Identifier (name) of a specific collection",
    "required" : true,
    "style" : "simple",
    "explode" : false,
    "schema" : {
        "type" : "string"
        }
    }

=================

==== Returns:

[[collectionInfo]]
.Collection Information
=================
[source,JSON]
"collectionInfo" : {
    "required" : [ "links", "name" ],
    "type" : "object",
    "properties" : {
        "name" : {
            "type" : "string",
            "description" : "identifier of the collection used, for example, in URIs",
            "example" : "buildings"
            },
        "title" : {
            "type" : "string",
            "description" : "human readable title of the collection",
            "example" : "Buildings"
            },
        "description" : {
            "type" : "string",
            "description" : "a description of the features in the collection",
            "example" : "Buildings in the city of Bonn."
            },
        "links" : {
            "type" : "array",
            "example" : [ {
                "href" : "http://data.example.org/collections/buildings/items",
                "rel" : "item",
                "type" : "application/geo+json",
                "title" : "Buildings"
                }, {
                "href" : "http://example.org/concepts/building.html",
                "rel" : "describedBy",
                "type" : "text/html",
                "title" : "Feature catalogue for buildings"
                } ],
            "items" : {
                "$ref" : "#/components/schemas/link"
                }
            },
        "extent" : {
            "$ref" : "#/components/schemas/extent"
            },
        "crs" : {
            "type" : "array",
            "description" : "The coordinate reference systems in which geometries may be retrieved. Coordinate reference systems are identified by a URI. The first coordinate reference system is the coordinate reference system that is used by default. This is always \"http://www.opengis.net/def/crs/OGC/1.3/CRS84\", i.e. WGS84 longitude/latitude.",
        "items" : {
            "type" : "string"
            },
        "default" : 
            [ "http://www.opengis.net/def/crs/OGC/1.3/CRS84" ]
            }
        }
    }

=================

=== Coverages Metadata

==== Path Template: 

/collections/{collectionId}/coverages

===== Path Parameters:

collectionId <<collectionId>>

===== Query Parameters:

*Limit Query Parameter*

[[query_parameter_limit]]
[width="90%",cols="2,6a"]
|===
2+|limit
|description |The optional limit parameter limits the number of items that are presented in the response document. +
Only items are counted that are on the first level of the collection in the response document. +
Nested objects contained within the explicitly requested items shall not be counted. 
|required |false,
|Schema | {
    "maximum" : 10000, +
    "minimum" : 1, +
    "type" : "integer", +
    "default" : 10
    }
|===

*Bounding Box Query Parameter*

[[query_parameter_bbox]]
[width="90%",cols="2,6a"]
|===
2+|bbox
|description |Only features that have a geometry that intersects the bounding box are selected. The bounding box is provided as four or six numbers, depending on whether the coordinate reference system includes a vertical axis (elevation or depth):

. Lower left corner, coordinate axis 1
. Lower left corner, coordinate axis 2
. (optional) Lower left corner, coordinate axis 3
. Upper right corner, coordinate axis 1
. Upper right corner, coordinate axis 2
. (optional) Upper right corner, coordinate axis 3

The coordinate reference system of the values is WGS84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system is specified in the parameter `bbox-crs`. 

For WGS84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).

If a feature has multiple spatial geometry properties, it is the decision of the server whether only a single spatial geometry property is used to determine the extent or all relevant geometries
|required |false,
|Schema | {
    "maxItems" : 6, +
    "minItems" : 4, +
    "type" : "array", +
    "Items" : {"type" : "number" }
    }
|===

*Time Query Parameter*

[[query_parameter_time]]
[width="90%",cols="2,6a"]
|===
2+|time
|description |Either a date-time or a period string that adheres to RFC 3339. Examples:

* A date-time: \"2018-02-12T23:20:50Z\"
* A period: \"2018-02-12T00:00:00Z/2018-03-18T12:31:12Z\" or \"2018-02-12T00:00:00Z/P1M6DT12H31M12S\"

Only features that have a temporal property that intersects the value of `time` are selected. +
If a feature has multiple temporal properties, it is the decision of the server whether only a single temporal property is used to determine the extent or all relevant temporal properties. 
|required |false,
|Schema | {
    "type" : "string"
    }
|===

==== Returns:

[[collectionGeoJSON]]
.Collection Information
=================
[source,JSON]
"collectionGeoJSON" : {
    "required" : [ "features", "type" ],
    "type" : "object",
    "properties" : {
        "type" : {
            "type" : "string",
            "enum" : [ "FeatureCollection" ]
            },
        "features" : {
            "type" : "array",
            "items" : {
                "$ref" : "#/components/schemas/featureGeoJSON"
                }
            },
        "links" : {
            "type" : "array",
            "items" : {
                "$ref" : "#/components/schemas/link"
                }
            },
        "timeStamp" : {
            "type" : "string",
            "format" : "dateTime"
            },
        "numberMatched" : {
            "minimum" : 0,
            "type" : "integer"
            },
        "numberReturned" : {
            "minimum" : 0,
            "type" : "integer"
            }
        }
    }
    
=================

=== Coverage (singular)

==== Path Template:

/collections/{collectionId}/coverages/{coverageID}

===== Path Parameters:

CollectionId <<collectionId>>

[[coverageId]]
.CoverageID Parameter
=================
[source,JSON]
"coverageId" : {
    "name" : "coverageId",
    "in" : "path",
    "description" : "Local identifier of a specific coverage",
    "required" : true,
    "style" : "simple",
    "explode" : false,
    "schema" : {
        "type" : "string"
        }
    }
    
=================

==== Returns:

[[featureGeoJSON]]
.Coverage Information
=================
[source,JSON]
"featureGeoJSON" : {
    "required" : [ "geometry", "properties", "type" ],
    "type" : "object",
    "properties" : {
        "type" : {
            "type" : "string",
            "enum" : [ "Feature" ]
            },
        "geometry" : {
            "$ref" : "#/components/schemas/geometryGeoJSON"
            },
        "properties" : {
            "type" : "object",
            "nullable" : true
            },
        "id" : {
            "oneOf" : [ {
                "type" : "string"
                }, {
                "type" : "integer"
                } ]
            }
        }
    }
        
=================

[[geometryGeoJSON]]
.Geometry Information
=================
[source,JSON]
"geometryGeoJSON" : {
    "required" : [ "type" ],
    "type" : "object",
    "properties" : {
        "type" : {
            "type" : "string",
            "enum" : [ "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection" ]
            }
        }
    }

=================

=== Domain Set of a Coverage

==== Path Template 

/collections/{collectionId}/coverages/{coverageID}/domainset

===== Path Parameters

collectionId <<collectionId>>

coverageId <<coverageId>>

==== Returns

[[domainSetJSON]]
.Domain Set Information
=================
[source,JSON]
"domainSetJSON" : {
    "required" : [ "type" ],
    "type" : "object",
    "properties" : {
        "type" : {
            "type" : "string"
            }
        }
    }

=================

=== Range Type of a Coverage

==== Path Template:

/collections/{collectionId}/coverages/{coverageID}/rangetype

===== Path Parameters

collectionId <<collectionId>>

coverageId <<coverageId>>

==== Returns

[[rangeTypeJSON]]
.Range Type Information
=================
[source,JSON]
"rangeTypeJSON" : {
    "type" : "object"
    }
        
=================

=== Requirement Class Subset
Without any subsetting parameter the whole coverage extent is the target resource addressed. If a subsetting operation is provided then the coverage subset indicated is the target resource addressed.

Coverage subsetting is indicated through the SUBSET parameter name. The value following the "=" symbol is built as follows:

    SubsetSpec:            SUBSET = axisName (intervalOrPoint)
    axisName:              {NCName}
    intervalOrPoint:       interval | point
    interval:              low : high
    low:                   point | *
    high:                  point | *
    point:                 {number} | "{text}"
    
    Where:
    " = double quote = ASCII code 0x42,
    {NCName} is an XML-style identifier not containing ":" (colon) characters, 
    {number} is an integer or floating-point number, and
    {text} is some general ASCII text (such as a time and date notation in ISO 8601). 
    
include::requirements/requirements_class_subset.adoc[]

==== Subsetting Examples

include::examples/examples_subsetting.adoc[]

=== Requirements Class Encodings

include::requirements/requirements_class_encoding.adoc[]




